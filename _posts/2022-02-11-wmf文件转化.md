---
layout:     post
title:      wmf文件转化
subtitle:   学习
date:       2022-02-11
author:     simplex
header-img: img/page_back.jpg
catalog: true
mathjax:  true
tags:
    - 学习	
---



最近在doc文件转md文件的时候，发现公式被转化为了wmf文件，为了转回jpg使用了一下两种方法

1

github上找了一个c#的转换，加上一定的缝合。没有用过c#，最后还是有图像失真的问题没有解决，十分丑陋。

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Drawing;
using System.Drawing.Imaging;
using System.IO;

namespace CS_WMF2JPG
{
    /*
     sample wmf file : https://example-files.online-convert.com/vector%20image/wmf/example.wmf
     convert wmf to jpg c# : https://social.msdn.microsoft.com/Forums/vstudio/en-US/6341c2b2-ca60-45f0-9253-fdd35469d155/convert-wmf-to-jpg?forum=csharpgeneral
     */
    class Program
    {
        static void Pause()
        {
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }

        /// <summary>
        /// 等比例缩放图片
        /// </summary>
        /// <param name="bitmap">图片</param>
        /// <param name="destHeight">高度</param>
        /// <param name="destWidth">宽度</param>
        /// <returns></returns>
        static Bitmap ZoomImage(Bitmap bitmap, int destHeight, int destWidth)
        {
            try
            {
                System.Drawing.Image sourImage = bitmap;
                int width = 0, height = 0;
                //按比例缩放
                int sourWidth = sourImage.Width;
                int sourHeight = sourImage.Height;
                if (sourHeight > destHeight || sourWidth > destWidth)
                {
                    if ((sourWidth * destHeight) > (sourHeight * destWidth))
                    {
                        width = destWidth;
                        height = (destWidth * sourHeight) / sourWidth;
                    }
                    else
                    {
                        height = destHeight;
                        width = (sourWidth * destHeight) / sourHeight;
                    }
                }
                else
                {
                    width = sourWidth;
                    height = sourHeight;
                }
                //width = sourWidth;
                //height = sourHeight;
                Bitmap destBitmap = new Bitmap(destWidth, destHeight);
                Graphics g = Graphics.FromImage(destBitmap);
                g.Clear(Color.Transparent);
                //设置画布的描绘质量
                g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;
                g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;
                g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
                g.DrawImage(sourImage, new Rectangle((destWidth - width) / 2, (destHeight - height) / 2, width, height), 0, 0, sourImage.Width, sourImage.Height, GraphicsUnit.Pixel);
                g.Dispose();
                //设置压缩质量
                System.Drawing.Imaging.EncoderParameters encoderParams = new System.Drawing.Imaging.EncoderParameters();
                long[] quality = new long[1];
                quality[0] = 100;
                System.Drawing.Imaging.EncoderParameter encoderParam = new System.Drawing.Imaging.EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality);
                encoderParams.Param[0] = encoderParam;
                sourImage.Dispose();
                return destBitmap;
            }
            catch
            {
                return bitmap;
            }
        }
        static void WMF2JPG(String StrInputFile)
        {
            if(!File.Exists(StrInputFile))
            {
                Console.Write("file not exist:" + StrInputFile+"\n");
                return;
            }
            String StrOutputFile = StrInputFile.Split('.')[0] + "_1.jpg";

            Image i = Image.FromFile(StrInputFile, true);
            Bitmap b = new Bitmap(i);
            
            int SCALE_RATO = 25;
            b = ZoomImage(b, b.Height / SCALE_RATO, b.Width / SCALE_RATO);
            b.SetResolution(250, 250);
            Graphics g = Graphics.FromImage(b);
            /*
                If I recall correctly, WMF files do not store a background color which causes them to be transparent and when you convert it as we did previously, the color ends up being no color at all (ie black).

                In order to fix that we need to do a little more, namely create a new image, set it's background color and then paint the WMF file on top of it.
            */
            g.Clear(Color.White);

            g.DrawImage(i, 0, 0, i.Width / SCALE_RATO, i.Height / SCALE_RATO);
            b.Save(StrOutputFile, ImageFormat.Jpeg);

        }
        static void Main(string[] args)
        {
            string basePath = @"D:\typora\f\media\";
            int i;
            for(i = 1; i <= 155; i++)
            {
                WMF2JPG(basePath + "image" + i.ToString() + ".wmf");
            }
            
            //Pause();
        }
    }
}

```



2

使用了python的PIL库，比较简单。不过存在的问题是虽然能够通过指定的分辨率加载，但是另存为jpg的文件我还是不会指定大小。

```python
from PIL import Image
import os

basrPath = r"D:\typora\f\media"


for i in range(1, 156):
    FileBaseName = basrPath + r"\image" + str(i)
    wmfName = FileBaseName + ".wmf"
    jpgName = FileBaseName + "_1.jpg"
    if os.path.exists(wmfName):
        with Image.open(wmfName) as im:
            im.load(dpi=144)
            im.save(jpgName, quality=100)
    else:
        print("missing wmf:" + str(i))


```

